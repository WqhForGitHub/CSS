> flex-direction
>
> 取值：row  |  row-reverse  |  column  |  column-reverse
>
> 初始值：row
>
> 适用于：弹性容器
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：否
>

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729170031332-72d5f92f-20be-4160-a59a-0eecbb59aaa5.png)

> flex-wrap
>
> 取值：nowrap  |  wrap  |  wrap-reverse
>
> 初始值：nowrap
>
> 适用于：弹性容器
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：否
>

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729170091718-e03fafdf-5048-4534-bf48-3ac7a0791db5.png)

+ 定义弹性流

> flex-flow
>
> 取值：<flex-direction>  | |  <flex-wrap>
>
> 初始值：row nowrap
>
> 适用于：弹性容器
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：否
>

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729170164423-c133f487-a749-48f6-a44a-ed67cc3235c2.png)



+ 调整内容

> justify-content
>
> 取值：flex-start  |  flex-end  |  center  |  space-between  |  space-around  |  space-evently
>
> 初始值：flex-start
>
> 适用于：弹性容器
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：否
>

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729170485549-de36d7f9-5c5c-43da-829d-fb654bf7eb29.png)

+ 对齐元素

> align-items
>
> 取值：flex-start  |  flex-end  |  center  |  baseline  |  stretch
>
> 初始值：stretch
>
> 适用于：弹性容器
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：否
>

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729223392080-abfcf13a-c49f-4cc0-85d1-fe4922fd833c.png)



+ <font style="color:rgb(51, 51, 51);">对齐内容</font>

> align-content
>
> 取值：flex-start | flex-end | center | space-between | space-around | space-evently | stretch 
>
> 初始值：stretch
>
> 适用于：分为多行显示的弹性容器
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：否
>



+ 适用于弹性元素的属性
1. <font style="color:rgb(51, 51, 51);">flex 属性</font>

> flex
>
> 取值：[ <flex-grow><flex-shrink> ? || <flex-basis> ] | none
>
> 初始值：0 1 auto
>
> 适用于：弹性元素（弹性容器的子元素）
>
> 百分数：只能作为 flex-basis 的值，相对父元素内的主轴尺寸计算
>
> 计算值：参见各单独属性
>
> 继承性：否
>
> 动画性：参见各单独属性
>

<font style="color:rgb(119, 119, 119);"></font>

```css
.flexItem {
  width: 50%;
  flex: 0 0 200px;
}
```

总结：在上述 CSS 中，弹性元素的主轴尺寸就是 200 像素，因为弹性基准的值是 200px。这个弹性元素既不能增大，也不能缩小。假设主轴是横向的，那么 width 的值（50%）将被忽略。类似地，如果主轴是纵向的，height 的值将被忽略。

注意：对 height 和 width 的覆盖不受层叠规则约束，因此即使为弹性元素的 height 或 width 值添加 !important 也不会覆盖弹性基准。

<font style="color:rgb(119, 119, 119);"></font>

2. <font style="color:rgb(51, 51, 51);">flex-grow 属性</font>

> flex-grow
>
> 取值：<number>
>
> 初始值：0
>
> 适用于：弹性元素（弹性容器的子元素）
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：是
>

定义：有多余空间时是否允许弹性元素增大，以及允许增大且有多余的空间时，相对其他同辈弹性元素以什么比例增大。

如果弹性容器中有多余的空间，多出的空间将根据各弹性元素的非零增长因子按比例分配给各个弹性元素。



如下图：例如有个宽度为 750px 的横排弹性容器，里面有三个弹性元素，而且都设置了 width: 100px; 因此，弹性元素共占 300 像素的空间，余下 450 像素的空间。此时，所有弹性元素都不允许增大。

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729322332293-ff9e18fa-2e4b-4a23-b672-377443d8c816.png)



如下图：只为一个弹性元素（第三个）设定了增长因子。我们声明的是 flex-grow：1，不过可以使用浏览器能理解的任何正数。此时，两个弹性元素没有增长因子，而第三个弹性元素有，因此所有可用空间都将分给设定了增长因子的那个弹性元素，所以，450 像素的可用空间都将添加到第三个弹性元素上，最终宽度为 550 像素。样式中为第三个弹性元素声明的 width: 100px 将被覆盖。

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729322734165-a9a712aa-352b-48f7-97a3-76b4e2f7b2dc.png)



如下图：虽然设定的弹性增长因子不同，但是得到的弹性元素宽度是一样的。先看第三种情况，这里各弹性元素的增长因子为 1、1 和 3。三个因子之和为 5。各因子除以总和，得到比例。这三个因子除以 5 后得到  0.2、0.2 和 0.6。这些比例乘以可用空间，得到增大的量。因此：

+ 450 px  ⨉ 0.2 = 90px
+ 450 px ⨉ 0.2 = 90px
+ 450 px ⨉ 0.6 = 270px

这些就是增加到弹性元素 100 像素初始宽度上的量。因此，最终得到的宽度分别为 190 像素、190 像素和 370 像素。

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729323018541-376cdc9c-7fdc-4d9b-9442-30e793021936.png)



如下图：在 flex 中设置和在 flex-grow 单独设置是不一样的。然而在使用 flex 时，弹性基准为 0%，全部空间将按比例分配给弹性元素，而不只是余下的空间。

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729326188652-30154469-5e41-44ec-b082-8f47fa2c5d55.png)

3. flex-shrink 

> flex-shrink
>
> 取值：<number>
>
> 初始值：1
>
> 适用于：弹性元素（弹性容器的子元素）
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：是
>









4. flex-basis 

> flex-basis
>
> 取值：content  |  [  <length>  |  <percentage>  ]
>
> 初始值：auto
>
> 适用于：弹性元素（弹性容器的子元素）
>
> 百分数：相对弹性容器内的主轴尺寸计算
>
> 计算值：指定的值，长度值计算为绝对长度
>
> 继承性：否
>
> 动画性：<width>
>

**定义：弹性元素的初始或默认尺寸，即根据增长因子和缩减因子分配多余或缺少的空间之前，弹性元素的大小。**

**全局关键字 initial 把弹性基准重置为初始值 auto ，因此也可以声明 auto。auto 的计算值等于 width 或 height，前提是声明了这两个属性。如果 width 或 height 的值为 auto，那么 flex-basis 的值计算为 content。**

> content 关键字
>
> 在支持的环境中，弹性基准等于弹性元素中内容的尺寸，即最长一行内容或最宽或最高那个媒体对象在主轴上的长度。它相当于在弹性元素上声明 flex-basis: auto; width: auto 或 flex-basis: auto; height: auto。
>
> 在下图中的的第一个例子和第三个例子，弹性元素的宽度等于内容的尺寸，弹性的基准也是。
>
> 在第一个例子中，弹性元素的宽度和基准大约为 132 像素。三个并排放置的弹性元素，总宽度为 396 像素，放在弹性容器中绰绰有余。第
>
> 第三个例子设置了空的缩放因子（0），弹性元素无法缩小，因此不会为了能在宽度固定的弹性容器中放得下而缩小或换行。这些弹性元素的宽度等于文本未换行时的宽度。这个宽度也是弹性基准的值。三个弹性元素的宽度和基准大约分别为 309、1037 和 523 像素。
>
> 在第二个例子中，弹性元素中的内容与第三个例子一样，但是弹性元素的缩减因子默认为 1，也就是说弹性元素可以缩小，因此这里的文本将换行。这种情况下，虽然弹性元素的宽度不等于内容的宽度，但是弹性基准（按比例缩小时的基准）等于内容的宽度。
>



![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729333500572-93d5b035-f082-498d-b5e6-696eb40ce78c.png)



**自动确定弹性基准**

设为 auto 时，不管是显式声明还是取默认值，flex-basis 等于元素在主轴方向上的尺寸，就像没把元素变成弹性元素一样。如果 width 或 height 的值是长度，弹性基准就等会那个长度；而如果 width 或 height 也是 auto，那么弹性基准回落为 content。

如果弹性基准为 auto ，而且弹性容器中能放下全部弹性元素，弹性元素的尺寸与未弹性变形之前一样。如果弹性容器中放不下弹性元素，弹性元素将根据未弹性变形之前的主轴尺寸按比例缩小（除非缩减因子为零）。

> 如下图一：如果没有其他属性设定弹性元素在主轴上的尺寸（即没有为弹性元素设定 width 或 min-width），而且声明了 flex-basis: auto 或 flex: 0 1 auto，那么弹性元素的宽度为恰好能放得下内容时的长度。此时，弹性元素的宽度等于 flex-basis: auto; 文本的宽度，大约为 110 像素。弹性元素的尺寸与未弹性变形之前一样，就像声明 display: inline-block。
>
> 如下图二：每个弹性元素的弹性基准都是 auto，而且显式声明了宽度。各弹性元素的主轴尺寸，即未变成弹性元素之前的尺寸分别为 100、150 和 200 像素。由于全部弹性元素能在弹性容器中放下，主轴方向上没有任何溢出。
>
> 如下图三：每个弹性元素的弹性基准都是 auto，而且显式声明了特别大的宽度。各弹性元素的主轴尺寸，即未变成弹性元素之前的尺寸分别为 2000、3000 和 4000 像素。因此，在不弹性变形的情况下，这三个弹性元素在主轴方向上将从弹性容器溢出。由于三个弹性元素的弹性缩减因子都默认为 1，所以它们将缩小，直到能在弹性容器中放下为止。第三个弹性元素的宽度由 4000 像素缩小为 240 像素。
>

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729337366277-dac919bf-5a29-4ab5-9453-9d786abc5389.png)



**默认值**

如果既没有声明 flex-basis，也没有声明 flex，那么弹性元素的主轴尺寸是未弹性变形时元素的尺寸，因为默认值是 auto。



**长度单位**

如果既设定了 flex-basis，又设定了 width （或主轴为纵向时的 height），弹性基准的优先级比宽度（或高度）高。虽然声明的弹性基准可以覆盖弹性元素的主轴尺寸，但是主轴尺寸还受其他属性的影响，例如 min-width、min-height、max-width 和 max-height。这些属性不会被忽略。因此，如果在一个元素上声明了 flex-basis: 100px 和 min-width: 500px，尽管弹性基准比最小宽度小，但还是以最小宽度为准。



**百分数**

记住：弹性基准为百分数值时，主轴尺寸相对弹性容器计算。



**零基准**

如果每个弹性元素的基准都是 0，那么可用空间将是整个弹性容器的主轴尺寸。





5. flex 简写属性

| flex: initial | 这个值根据 width 或 height 属性（由主轴方向上决定）确定弹性元素的尺寸，而且允许缩小。 |
| --- | --- |
| flex: auto | 这个值也根据 width 或 height 属性确定弹性元素的尺寸，但是元素是完全弹性的，既可以缩小也可以增大。 |
| flex: none | 这个值还是根据 width 或 height 属性确定弹性元素的尺寸，但是元素完全没有弹性，不能缩小也不能增大。 |
| flex: <number> | 这个值把弹性元素的增长因子设为 <number> 指定的数，同时把缩减因子设为 1，把基准也设为 0。这意味着，width 或 height 属性的值相当于最小尺寸，弹性元素在有多余的空间时将增大。 |


**initial 值**

这两个声明等效

```css
flex: initial;
flex: 0 1 auto;
```



**auto 值**

```css
flex: auto;
flex: 1 1 auto;
```



**none 值**

```css
flex: none;
flex: 0 0 auto;
```



**数字值**

如果 flex 属性只有一个值，而且是正数，那个值将用作增长因子，而缩减因子默认为 0，基准也默认为 0。

```css
flex: 3;
flex: 3 1 0;
```

                                                                                                                                    

6. order

order 属性用于修改单个弹性元素的显示顺序。

> order
>
> 取值：<integer>
>
> 初始值：0
>
> 适用于：弹性元素以及弹性容器中绝对定位的子元素
>
> 计算值：指定的值
>
> 继承性：否
>
> 动画性：是
>

默认情况下，所有弹性元素的顺序都是 0，归在同一个排序组中，以出现在源码中的顺序沿主轴方向显示。

若想修改弹性元素的视觉顺序，把 order 属性设为一个非零整数。如果 order 属性的目标元素不是弹性容器的子元素，元素不受影响。

order 属性为负数的弹性元素显示在采用默认值 0 的弹性元素前面，而 order 属性为正数的弹性元素显示在采用默认值 0 的弹性元素后面。虽然弹性元素的视觉顺序变了，但是在源码中的顺序没变。屏幕阅读器的阅读顺序和 Tab 键的索引顺序都由 HTML 源码顺序定义。

```css
ul {
  display: inline-flex;
}

li:nth-of-type(6) {
  order: 1;
}

li:nth-of-type(7) {
  order: -1;
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729408218357-abd5c646-c608-4654-9d20-bed195c08838.png)

```css
ul {
  display: inline-flex;
  background-color: rgba(0, 0, 0, 0.1);
}

li:nth-of-type(3n - 1) {
  order: 3;
  background-color: rgba(0, 0, 0, 0.2);
}

li:nth-of-type(3n + 1) {
  order: -1;
  background-color: rgba(0, 0, 0, 0.4);
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/166664/1729408553292-086292b7-5d3f-4b3c-9ea6-0246830a740d.png)

